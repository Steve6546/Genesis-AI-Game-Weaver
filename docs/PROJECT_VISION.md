# رؤية مشروع Genesis AI Game Weaver

## 1. الفكرة الكبرى للمشروع (The Big Picture)

**الهدف النهائي:**
يهدف مشروع "Genesis AI Game Weaver" إلى إحداث ثورة في طريقة تطوير الألعاب، بجعلها عملية سهلة، سريعة، ومتاحة للجميع، حتى لمن ليس لديهم خبرة برمجية عميقة. نطمح لإنشاء منصة يمكنها فهم الأفكار المعبر عنها باللغة الطبيعية (مثل العربية أو الإنجليزية) وتحويلها تلقائيًا إلى ألعاب ثنائية الأبعاد (ولاحقًا ثلاثية الأبعاد) قابلة للعب والتعديل الفوري.

**ما الذي يميزه عن المحركات الأخرى (مثل Godot, Unity)؟**
*   **التركيز على اللغة الطبيعية:** بينما تعتمد المحركات التقليدية على واجهات رسومية معقدة وكتابة أكواد برمجية، يركز Genesis على التفاعل المباشر من خلال الأوامر النصية أو الصوتية. الهدف هو "صف لعبتك، ثم العبها".
*   **السرعة في إنشاء النماذج الأولية:** مثالي لتجربة الأفكار بسرعة فائقة وإنشاء نماذج أولية للألعاب دون الحاجة لقضاء وقت طويل في الإعدادات التقنية.
*   **الذكاء الاصطناعي في الصميم:** ليس مجرد أداة، بل نظام ذكي يساعد في التصميم، التوليد، وحتى اقتراح التحسينات.
*   **سهولة الوصول:** يهدف لتمكين شريحة أوسع من المبدعين (مصممي الألعاب، الكتاب، الهواة) من تحويل أفكارهم إلى واقع.

**لماذا نصنعه؟ ومن سيستخدمه؟**
نصنعه لكسر الحواجز التقنية أمام صناعة الألعاب. سيستخدمه:
*   **مطورو الألعاب المستقلون:** لتسريع عملية تطوير النماذج الأولية.
*   **مصممو الألعاب:** لتركيز جهودهم على التصميم والإبداع بدلاً من البرمجة المعقدة.
*   **المعلمون والطلاب:** كأداة تعليمية مبتكرة لتعلم مفاهيم تصميم الألعاب والذكاء الاصطناعي.
*   **الهواة والمبدعون:** أي شخص لديه فكرة لعبة ويريد رؤيتها تنبض بالحياة بسرعة.

**رؤيتنا طويلة الأمد:**
أن يصبح Genesis AI Game Weaver منصة تطوير ألعاب متكاملة وقوية، تعتمد بشكل أساسي على الذكاء الاصطناعي، وتدعم مجتمعًا من المبدعين يشاركون ألعابهم وأفكارهم.

---

## 2. إلى أين وصلنا الآن؟ (Current Progress)

لقد تم إنجاز مراحل تأسيسية مهمة في المشروع، مما يوفر قاعدة صلبة للتطويرات المستقبلية. التفاصيل الكاملة لما تم إنجازه موجودة في `ARCHITECTURE.md` و `HOW_TO_RUN.md`، ولكن باختصار:

*   **محرك عرض ألعاب ثنائي الأبعاد:** باستخدام Pygame، يمكن للمحرك عرض كيانات بأشكال (مستطيلات، دوائر)، ألوان، وأحجام مختلفة. يدعم تحريك هذه الكيانات بناءً على أنماط محددة.
*   **نظام مخططات الألعاب (Game Schema):** يتم تعريف الألعاب بشكل كامل من خلال ملفات JSON تتبع هيكلًا محددًا (JSON Schema). هذا المخطط يصف كل شيء في اللعبة: من عنوانها وأبعاد شاشتها إلى تفاصيل كل كيان (لاعب، عدو، مقذوف) وسلوكه.
*   **التحقق من صحة المخططات:** يتم استخدام مكتبة `jsonschema` لضمان أن أي مخطط لعبة يتم تحميله أو توليده يلتزم بالبنية المحددة، مما يقلل الأخطاء.
*   **محاكاة الذكاء الاصطناعي:** تم بناء دوال تحاكي قدرة نماذج اللغة الكبيرة (LLMs) على:
    *   توليد مخطط لعبة جديد من وصف نصي (بسيط حاليًا).
    *   تصحيح مخطط لعبة يحتوي على أخطاء بناءً على رسالة الخطأ والمخطط الأصلي.
*   **دعم أنواع ألعاب متنوعة (مبدئيًا):**
    *   **ألعاب المنصات البسيطة/تجنب العقبات:** لاعب يتحرك أفقيًا، وعقبات تسقط من الأعلى.
    *   **ألعاب إطلاق النار من منظور علوي (Top-Down Shooter):** لاعب يتحرك في جميع الاتجاهات، يطلق مقذوفات، أعداء لديهم نقاط صحة، ونظام اصطدام متقدم.
*   **ميكانيكيات اللعب الأساسية:**
    *   **التحكم باللاعب:** حركة أفقية، وحركة متعددة الاتجاهات.
    *   **حركة الكيانات الأخرى:** ثابتة، سقوط، دوريات (يمين ويسار).
    *   **إطلاق النار:** إنشاء مقذوفات، نظام تهدئة (cooldown).
    *   **المقذوفات:** حركة، مدة بقاء، إزالة عند الخروج من الشاشة.
    *   **نظام الصحة:** للكيانات القابلة للتدمير (مثل الأعداء واللاعب).
    *   **اكتشاف الاصطدامات:** بين اللاعب والأعداء/العقبات، وبين المقذوفات والأعداء، مع تأثيرات مثل فقدان الصحة أو تدمير الكيان.
*   **واجهة سطر الأوامر (CLI):** لتشغيل اللعبة، تحديد ملف المخطط، واختيار وضع التشغيل (تفاعلي حي أو حفظ إطار واحد).

**ما الذي يعمل الآن؟**
*   تحميل مخططات الألعاب من ملفات JSON.
*   التحقق من صحة هذه المخططات.
*   محاكاة تصحيح المخططات الخاطئة (باستخدام مخططات مُعدة مسبقًا).
*   عرض الألعاب ثنائية الأبعاد بناءً على المخططات الصحيحة.
*   التفاعل مع اللاعب (الحركة، إطلاق النار) في الألعاب التي تدعم ذلك.
*   تطبيق ميكانيكيات اللعب المذكورة أعلاه (الحركة، الاصطدام، الصحة، إلخ).

**ما الذي لا يعمل بعد (أو قيد التطوير الأولي)؟**
*   **التكامل الفعلي مع نماذج لغة كبيرة (LLMs) مثل Gemini:** حاليًا، نستخدم محاكاة. الربط الفعلي يتطلب API Key وإعدادات إضافية.
*   **فهم الأوامر اللغوية المعقدة:** المحاكاة الحالية بسيطة وتعتمد على كلمات مفتاحية.
*   **توليد مخططات ألعاب معقدة ديناميكيًا بالكامل من أوامر لغوية:** ما زلنا في المراحل الأولى.
*   **واجهة مستخدم رسومية (GUI):** التفاعل حاليًا يتم عبر سطر الأوامر وملفات JSON.
*   **ذكاء اصطناعي متقدم للأعداء:** الأعداء حاليًا يتبعون أنماط حركة بسيطة.
*   **دعم الأوامر الصوتية.**
*   **حفظ وتحميل حالة اللعبة.**
*   **محرر ألعاب مرئي متكامل.**

---

## 3. خريطة الطريق (Roadmap) - دفعات التطوير القادمة

سيتم تطوير المشروع على دفعات (Milestones) لضمان التقدم المنظم والقابل للقياس:

**الدفعة 0: التأسيس ومحرك العرض (تم إنجاز معظمه)**
*   **الهدف:** بناء النواة الأساسية للمشروع.
*   **لماذا:** لتوفير الأساس الذي ستبنى عليه جميع الميزات المستقبلية.
*   **كيف:** تطوير محرك عرض Pygame، نظام مخططات JSON، وآليات التحقق والمحاكاة الأولية.
*   **الحالة:** مكتمل إلى حد كبير.

**الدفعة 1: دعم أنواع ألعاب أساسية (تم إنجاز معظمه)**
*   **الهدف:** تمكين النظام من إنشاء وعرض أنواع ألعاب بسيطة ومتنوعة.
*   **لماذا:** لإثبات قدرة المفهوم على توليد ألعاب مختلفة.
*   **كيف:** توسيع مخطط اللعبة ومحرك العرض لدعم ميكانيكيات مثل الحركة متعددة الاتجاهات، إطلاق النار، المقذوفات، نظام الصحة، والاصطدامات المتقدمة (تم تطبيقه في لعبة Top-Down Shooter).
*   **الحالة:** مكتمل إلى حد كبير.

**الدفعة 2: التكامل الأولي مع نماذج اللغة الكبيرة (LLM Integration - Phase 1)**
*   **الهدف:** استبدال المحاكاة الحالية بربط فعلي (مبدئي) مع نموذج لغة كبير (مثل Gemini).
*   **لماذا:** لجعل عملية توليد وتصحيح المخططات أكثر ذكاءً ومرونة.
*   **كيف:**
    *   إعداد الاتصال مع Gemini API (أو نموذج آخر).
    *   تعديل الدوال `generate_schema_from_prompt` و `generate_corrected_schema_from_prompt` لاستدعاء الـ API فعليًا.
    *   بناء نماذج أولية للـ "prompts" التي سيتم إرسالها للنموذج.
    *   معالجة الاستجابات من النموذج وتحويلها إلى مخططات JSON.
    *   اختبار قدرة النموذج على فهم أوامر بسيطة وتوليد مخططات صحيحة.
*   **المقياس:** القدرة على إعطاء أمر نصي بسيط (مثل "أنشئ لعبة لاعب يتحرك يمينًا ويسارًا ويتجنب كرة تسقط") والحصول على مخطط لعبة صحيح وقابل للتشغيل.

**الدفعة 3: تحسين فهم الأوامر وتوليد المخططات (LLM Integration - Phase 2)**
*   **الهدف:** زيادة قدرة النظام على فهم أوامر لغوية أكثر تعقيدًا وتنوعًا.
*   **لماذا:** للاقتراب من تجربة المستخدم المثالية حيث يمكن وصف اللعبة بشكل طبيعي.
*   **كيف:**
    *   هندسة "prompts" أكثر تفصيلاً وتطورًا.
    *   استكشاف تقنيات مثل "few-shot learning" أو "chain-of-thought prompting" لتحسين أداء النموذج.
    *   إضافة القدرة على طرح أسئلة توضيحية إذا كان الأمر غامضًا.
    *   دعم تعديل الكيانات الموجودة أو إضافة كيانات جديدة من خلال الأوامر.
*   **المقياس:** القدرة على وصف لعبة بسيطة (مثل Pong أو Snake) بأوامر متعددة والحصول على نتيجة صحيحة.

**الدفعة 4: إضافة ذكاء اصطناعي أساسي للأعداء (Basic Enemy AI)**
*   **الهدف:** جعل الأعداء أكثر تفاعلية وتحديًا.
*   **لماذا:** لتحسين تجربة اللعب وجعل الألعاب أكثر إثارة.
*   **كيف:**
    *   توسيع مخطط اللعبة ليشمل سلوكيات AI بسيطة (مثل: "ملاحقة اللاعب"، "إطلاق النار على اللاعب عند الاقتراب"، "الحركة بشكل عشوائي").
    *   تنفيذ هذه السلوكيات في محرك العرض.
    *   السماح للمستخدم بتحديد سلوك الأعداء من خلال الأوامر اللغوية.
*   **المقياس:** القدرة على إنشاء أعداء يظهرون سلوكًا ذكيًا (بسيطًا) بناءً على أوامر المستخدم.

**الدفعة 5: واجهة مستخدم رسومية أساسية (Basic GUI)**
*   **الهدف:** توفير واجهة أكثر سهولة للاستخدام من سطر الأوامر.
*   **لماذا:** لجعل النظام متاحًا لشريحة أوسع من المستخدمين.
*   **كيف:**
    *   استخدام مكتبة مثل Tkinter, PyQt, أو Kivy (أو حتى واجهة ويب بسيطة باستخدام Flask/Django مع Eel).
    *   توفير حقل لإدخال الأوامر النصية.
    *   عرض اللعبة المولدة داخل الواجهة.
    *   أزرار للتحكم الأساسي (بدء، إيقاف، إعادة تعيين).
*   **المقياس:** واجهة رسومية بسيطة تعمل وتسمح بالتفاعل الأساسي مع النظام.

**الدفعة 6: دعم الأوامر الصوتية (Voice Commands)**
*   **الهدف:** توفير طريقة إدخال إضافية ومبتكرة.
*   **لماذا:** لزيادة سهولة الاستخدام وتوفير تجربة فريدة.
*   **كيف:**
    *   دمج مكتبات التعرف على الكلام (مثل SpeechRecognition في Python).
    *   تحويل الكلام إلى نص يتم تمريره إلى نظام فهم الأوامر الحالي.
*   **المقياس:** القدرة على إعطاء أوامر صوتية بسيطة يتم تنفيذها بنجاح.

---

## 4. رؤية مستقبلية بعيدة (Long-term Vision & Advanced Features)

هذه أفكار وميزات نطمح لإضافتها على المدى الطويل لجعل المشروع منصة متكاملة وقوية:

*   **محرك ألعاب أصلي متكامل (Custom Game Engine):**
    *   تطوير محرك ألعاب خاص بالمشروع (قد يكون مبنيًا على Pygame في البداية ثم يتطور) يكون مُحسَّنًا للتوليد الديناميكي والتعديل الفوري.
    *   دعم أفضل للرسوميات، المؤثرات الصوتية، والفيزياء.
*   **دعم الألعاب ثلاثية الأبعاد (3D Game Support):**
    *   توسيع النظام ليشمل القدرة على توليد وعرض ألعاب ثلاثية الأبعاد بسيطة (باستخدام مكتبات مثل Ursina, Panda3D, أو حتى تصدير لمحررات مثل Godot).
*   **تخصيص متقدم للرسومات والأصوات:**
    *   السماح للمستخدمين بوصف الأشكال المرئية للكيانات أو حتى رفع صور/نماذج خاصة بهم.
    *   توليد أو اختيار مؤثرات صوتية وموسيقى بناءً على وصف اللعبة.
    *   الربط مع نماذج توليد الصور (مثل DALL-E, Stable Diffusion) لتوليد أصول اللعبة (sprites, textures) بناءً على الأوامر.
*   **ذكاء اصطناعي متقدم وتوليد محتوى إجرائي (Advanced AI & Procedural Content Generation - PCG):**
    *   سلوكيات أعداء أكثر تعقيدًا (Pathfinding, State Machines).
    *   توليد مستويات (Levels) بشكل إجرائي بناءً على معايير يحددها المستخدم.
    *   شخصيات غير قابلة للعب (NPCs) تتفاعل بشكل ذكي مع اللاعب أو البيئة.
*   **نظام "بلجن" (Plugin System) للذكاء الاصطناعي:**
    *   السماح بتبديل نماذج اللغة الكبيرة أو دمج نماذج متخصصة بسهولة.
*   **مجتمع ومشاركة (Community & Sharing):**
    *   منصة لمشاركة الألعاب التي تم إنشاؤها، والمخططات، وحتى "الأوامر" الناجحة.
*   **محرر مرئي مساعد (Visual Helper Editor):**
    *   واجهة رسومية تسمح بتعديل المخططات المولدة بشكل مرئي، بالإضافة إلى الأوامر النصية.
*   **تصدير الألعاب (Game Export):**
    *   القدرة على تصدير اللعبة كملف تنفيذي مستقل أو لمشاركتها على الويب.
*   **التعلم والتحسين الذاتي للنظام:**
    *   أن يتعلم النظام من تفاعلات المستخدمين والأوامر الناجحة لتحسين فهمه وقدرته على التوليد.

---

## 5. أفكار قابلة للإضافة لاحقًا (Backlog / Nice-to-haves)

*   دعم اللعب الجماعي البسيط (Local Multiplayer).
*   تكامل مع أنظمة التحكم في الإصدار (Git) لحفظ تطور الألعاب.
*   أدوات لتصحيح الأخطاء (Debugging) داخل الألعاب المولدة.
*   دعم لغات برمجة نصية (Scripting) بسيطة داخل الألعاب لمزيد من التخصيص المتقدم.
*   توليد قصص أو حوارات بسيطة للشخصيات باستخدام LLMs.

---

هذا الملف يمثل الرؤية الحالية للمشروع وهو قابل للتحديث والتطوير مع تقدم العمل.
