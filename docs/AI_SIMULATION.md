# محاكاة الذكاء الاصطناعي في Genesis AI Game Weaver

## 1. الغرض من المحاكاة (Purpose of Simulation)

في المراحل الحالية من تطوير مشروع Genesis AI Game Weaver، لا يتم الاعتماد بشكل مباشر على نماذج لغة كبيرة (LLMs) حقيقية مثل Gemini لمعالجة أوامر المستخدم أو توليد/تصحيح مخططات الألعاب. وذلك لعدة أسباب:

*   **التركيز على البنية الأساسية:** الأولوية كانت لبناء محرك العرض، نظام مخططات الألعاب، وآليات التحقق الأساسية.
*   **تكلفة وتعقيد الـ API:** استخدام واجهات برمجة تطبيقات (APIs) لنماذج اللغة يتطلب مفاتيح API، إدارة للحصص (quotas)، ومعالجة لاحتمالية الأخطاء في الاتصال أو الاستجابات غير المتوقعة.
*   **سرعة التطوير والاختبار:** الاعتماد على محاكاة يسمح باختبار تدفق العمل بشكل أسرع ودون الحاجة لانتظار استجابات من API خارجي.

بدلاً من ذلك، تم بناء **نظام محاكاة** داخل `main.py` يقلد السلوك المتوقع من نموذج لغة كبير في سياق المشروع.

## 2. كيف تعمل المحاكاة؟

تتركز المحاكاة في دالتين رئيسيتين داخل `main.py`:

### أ. `generate_schema_from_prompt(prompt: str) -> dict | None`

*   **الوظيفة المحاكاة:** هذه الدالة تحاكي قدرة نموذج لغة كبير على فهم وصف نصي للعبة (الـ `prompt`) وتوليد مخطط لعبة JSON كامل بناءً على هذا الوصف.
*   **التنفيذ الحالي (محاكاة):**
    *   الدالة لا تقوم بتحليل لغوي معقد للـ `prompt`.
    *   بدلاً من ذلك، تحتوي على منطق شرطي بسيط يبحث عن كلمات مفتاحية محددة في الـ `prompt`.
    *   إذا تم العثور على كلمة مفتاحية معينة (مثل "faulty" أو "simple game" أو "red circle"), تقوم الدالة بإرجاع مخطط لعبة JSON مُعد مسبقًا ومخزن مباشرة في كود الدالة.
    *   إذا لم يتم التعرف على أي كلمة مفتاحية، قد تُرجع مخططًا افتراضيًا بسيطًا أو `None`.
    *   **مثال:** إذا كان الـ `prompt` يحتوي على كلمة "faulty", قد تُرجع الدالة محتوى مشابه لملف `faulty_game_schema.json`.
*   **الهدف المستقبلي (مع LLM حقيقي):** سيتم استبدال هذا المنطق باستدعاء فعلي لـ Gemini API، حيث يتم إرسال الـ `prompt` (مع توجيهات إضافية حول تنسيق الإخراج المطلوب) إلى النموذج، ويُتوقع من النموذج أن يُرجع سلسلة JSON تمثل مخطط اللعبة.

### ب. `generate_corrected_schema_from_prompt(prompt: str) -> dict | None`

*   **الوظيفة المحاكاة:** هذه الدالة تحاكي قدرة نموذج لغة كبير على أخذ مخطط لعبة خاطئ، رسالة الخطأ التي نتجت عن التحقق منه، والوصف الأصلي للعبة (أو تعريف المخطط الصحيح)، ثم توليد نسخة مصححة من مخطط اللعبة.
*   **الـ `prompt` المُستخدم:** يتم بناء الـ `prompt` لهذه الدالة بواسطة `build_gemini_correction_prompt(...)`. هذا الـ prompt (نظريًا) سيوجه Gemini لتصحيح الخطأ.
*   **التنفيذ الحالي (محاكاة):**
    *   بغض النظر عن محتوى الـ `prompt` الذي يتم تمريره إليها (والذي يحاكي ما سيُرسل إلى Gemini)، تقوم الدالة حاليًا بإرجاع مخطط لعبة مُصحح ومُعد مسبقًا.
    *   في الإصدارات الأخيرة، هذا المخطط المُعد مسبقًا هو مخطط لعبة Top-Down Shooter متكاملة.
    *   هذا يعني أن "محاكاة Gemini" لدينا قادرة دائمًا على "تصحيح" أي خطأ يُعرض عليها (لأغراض الاختبار) عن طريق تجاهل الخطأ الفعلي وإرجاع هذا المخطط القياسي المصحح.
*   **الهدف المستقبلي (مع LLM حقيقي):** سيتم إرسال الـ `prompt` المُفصل (الذي يحتوي على المخطط الخاطئ، الخطأ، وتعريف المخطط الصحيح) إلى Gemini API. سيُتوقع من النموذج أن يفهم المشكلة ويُرجع سلسلة JSON تمثل المخطط المصحح.

## 3. بناء الـ Prompt للتصحيح: `build_gemini_correction_prompt(...)`

هذه الدالة مساعدة تقوم بتجميع النص الذي سيتم (نظريًا) إرساله إلى Gemini لطلب تصحيح مخطط خاطئ. يتضمن هذا النص:

*   الاستعلام الأصلي للمستخدم (إذا كان متاحًا، أو وصف عام للعبة المطلوبة).
*   المخطط الخاطئ بصيغة JSON.
*   رسالة الخطأ التي نتجت عن التحقق من صحة المخطط.
*   تعريف مخطط JSON Schema الصحيح (محتوى `GAME_SCHEMA_DEFINITION`).

الفكرة هي تزويد النموذج بكل المعلومات اللازمة لفهم السياق، الخطأ، والبنية المتوقعة للإصلاح.

## 4. حدود المحاكاة الحالية

*   **ليست ذكية:** المحاكاة لا تفهم اللغة الطبيعية بشكل حقيقي ولا تقوم بتوليد ديناميكي للمخططات بناءً على أوامر متنوعة.
*   **محدودة الاستجابات:** تُرجع دائمًا مخططات مُعدة مسبقًا.
*   **لا تتعلم:** لا تتحسن قدرتها مع الوقت أو كثرة الاستخدام.

## 5. لماذا هي مفيدة رغم ذلك؟

*   **تسمح بتطوير بقية النظام:** يمكن بناء واختبار مدقق المخطط، محرك العرض، وتدفق العمل العام دون انتظار تكامل LLM فعلي.
*   **توضح تدفق البيانات المتوقع:** تُظهر كيف سيتم (نظريًا) استدعاء دوال الـ LLM وما هو نوع البيانات المتوقع منها.
*   **تسهل الاختبارات الأولية:** يمكن بسهولة اختبار سيناريوهات النجاح والفشل في التحقق والتصحيح.

عندما يتم الانتقال إلى استخدام Gemini API فعليًا، سيتم استبدال المنطق الداخلي لدوال المحاكاة هذه باستدعاءات API حقيقية، مع الحفاظ على واجهة الدالة (المدخلات والمخرجات المتوقعة) قدر الإمكان لتقليل التغييرات في بقية أجزاء الكود.
